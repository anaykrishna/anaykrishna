alias func_num R1;
alias curr_pid R2;

if(func_num == 3) then					//Acquire Disk
	while([DISK_STATUS_TABLE] == 1) do	//Busy Loop
		[PROCESS_TABLE + 16*curr_pid + 4] = WAIT_DISK;
		multipush(R0, R1, R2);
		call SCHEDULER;
		multipop(R0, R1, R2);
	endwhile;

	[DISK_STATUS_TABLE + 0] = 1;
	[DISK_STATUS_TABLE + 4] = curr_pid;
	return;
endif;

if(func_num == 8) then
    while([TERMINAL_STATUS_TABLE] == 1) do
        [PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE+1] + 4] = WAIT_TERMINAL;  //change to curr_pid
        multipush(R0, R1, R2);
        call SCHEDULER;							//Schedule other processes while it waits.
        multipop(R0, R1, R2);
    endwhile;

    [TERMINAL_STATUS_TABLE] = 1;				//Once free set the status of terminal for the current process.
    [TERMINAL_STATUS_TABLE+1] = curr_pid;
    breakpoint;
    return;
endif;

if(func_num == 9)then
    if([TERMINAL_STATUS_TABLE+1] != curr_pid) then
        R0 = -1;								//Can't be called from process that has not acquired the terminal.
        return;
    endif;

    [TERMINAL_STATUS_TABLE] = 0;				//Release complete.

    R1 = 1;
    while(R1 < 16) do
        if([PROCESS_TABLE + 16*R1 + 4] == WAIT_TERMINAL) then
            [PROCESS_TABLE + 16*R1 + 4] = READY;
        endif;
        R1 = R1+1;
    endwhile;

    R0 = 0;										//Successful return value
    breakpoint;
    return;
endif;
