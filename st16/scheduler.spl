alias curr_process R0;
curr_process = [SYSTEM_STATUS_TABLE+1];

multipush(BP);

[PROCESS_TABLE + 16*curr_process + 12] = SP%512; //user stack saved in timer interrupt
[PROCESS_TABLE + 16*curr_process + 14] = PTBR;
[PROCESS_TABLE + 16*curr_process + 15] = PTLR;

curr_process = curr_process + 1;

//find the pid of the next ready or created process.

while(
[PROCESS_TABLE + 16*curr_process + 4] != READY 
&&
[PROCESS_TABLE + 16*curr_process + 4] != CREATED) do
	curr_process = (curr_process + 1) % 16;
endwhile;

//set the pointers to that of new process.

SP = 512*[PROCESS_TABLE + 16*curr_process + 11] + [PROCESS_TABLE + 16*curr_process + 12];
PTBR = [PROCESS_TABLE + 16*curr_process + 14];
PTLR = [PROCESS_TABLE + 16*curr_process + 15];

[SYSTEM_STATUS_TABLE + 1] = curr_process;

//In case of a created process transfer control directly to the user program.

if([PROCESS_TABLE + 16*curr_process + 4] == CREATED) then
	SP = [PROCESS_TABLE + 16*curr_process + 13];
	[PROCESS_TABLE + 16*curr_process + 4] = RUNNING;
	[PROCESS_TABLE + 16*curr_process + 9] = 0;		// why are we doing this??
	ireturn;
endif;

[PROCESS_TABLE + 16*curr_process + 4] = RUNNING;
multipop(BP);
return;
